\section{Trabalhos relacionados}\label{sec:trabRelac}

Ao longo dos anos uma grande variedade de \textit{frameworks} e metodologias vem sendo prosposta para suportar \gls{ca} em diferentes níveis de abstração. Os trabalhos apresentados nessa seção buscam prover técnicas em nível de \textit{runtime} e também buscam prover um equilibrío entre ganhos eficiência e qualidade de saída, usualmente utilizando estratégias de estatistíca, adaptação em tempo \textit{runtime} ou anotações em nível de linguagem de programação.

\texttt{ApproxHadoop}~\cite{goiri2015} é uma extensãoa ao \texttt{Hadoop} para suportar o descarte de seletivo tarefas (\textit{task dropping}) no \texttt{MapReduce}. Por meio de um mecanismo de amostragem dos dados de entrada, a extensão visa reduzir o tempo de execução e o consumo de recursos ao evitar o processamento completo dos dados, sem perder de vista a utilidade prática dos resultados. Além disso, o sistema integra métodos estatísticos que calculam limites de erro, fornecendo garantias quantitativas sobre a precisão das respostas aproximadas.

Rinard~\cite{rinard2006} propôs uma metodologia de particionamento da computação em tarefas que podem ser descartadas, seja em resposta a falhas ou de forma deliberada para melhorar o desempenho. Em sua abordagem a aplicação é decomposta em tarefas, que são analisdas para distinguir as essenciais daquelas que podem ser descartas, isso é feito por meio de um teste onde o programa é executado e a \textit{runtime} insere falhas de maneira proposital para verificar se o programa suporta aquela falha ou não, e também é usado um modelo de regrassão obtido por amostragem repetida para prever os efeitos dessas omissões.

Lashgar et al.~\cite{lashgar2018} propõem a integração da técnica de perforação de laço ao \texttt{OpenACC} com o objetivo de melhorar o desempenho, executando apenas um subconjunto das iterações do laço. Dessa forma, parte das saídas é calculada de maneira exata, enquanto o restante é aproximado. Para mitigar os impactos dessa abordagem na precisão e no tempo de execução dentro do \texttt{OpenACC}, os autores introduzem um mecanismo de correção implementado diretamente no kernel. Esse mecanismo identifica as saídas ausentes e aplica estratégias como a cópia ou a média dos valores vizinhos já computados, a fim de estimar as entradas faltantes.

O \texttt{Sculptor}~\cite{li2018} é um \textit{framework} geral para perforação de laço dinâmica e seletiva, que avança em relação às técnicas tradicionais ao permitir aproximações em nível fino, tanto no nível de instruções individuais quanto no nível das iterações. Diferentemente das abordagens clássicas, que pulam um subconjunto fixo de iterações de forma uniforme, o \texttt{Sculptor} seleciona dinamicamente quais instruções devem ser ignoradas dentro dos laços e ajusta, em tempo de execução, as taxas de perfuração e os pontos de início de acordo com o comportamento do programa. Ele emprega uma \textit{pipeline} de otimizações do compilador em múltiplas etapas, capaz de identificar instruções com baixo impacto na precisão, mas alto potencial de ganho de desempenho, transformando os laços de forma adequada. Além disso, o \textit{framework} inclui escalonadores dinâmicos que adaptam o grau de agressividade da perfuração entre diferentes contextos de chamada e fases do laço.

O \texttt{SampleMine}~\cite{jiang2022} é um \textit{framework} que acelera a mineração de padrões em subgrafos aplicando perforação de laço nos laços aninhados usados na exploração dos subgrafos. Ele introduz uma técnica de expansão baseada em dois vértices, na qual cada passo adiciona dois vértices ao subgrafo, reduzindo a complexidade computacional em comparação com os métodos tradicionais, que acrescentam apenas um vértice por iteração.

Vassiliadis et al.~\cite{vassiliadis2015} propõem um \textit{framework} que introduz um modelo de programação baseado em tarefas, no qual os desenvolvedores podem anotar cada tarefa com um nível de significância e, opcionalmente, fornecer versões aproximadas. A \textit{runtime} decide dinamicamente quais tarefas devem ser executadas de forma precisa ou aproximada, de acordo com as restrições de qualidade definidas pelo usuário. Duas políticas de execução são implementadas: \textit{Global Task Buffering (GTB)}, que armazena tarefas para permitir decisões globalmente informadas, e \textit{Local Queue History (LQH)}, que se baseia no histórico local das tarefas para decisões descentralizadas e mais rápidas.

\texttt{HPAC}~\cite{parasyris2021} é um \textit{framework} que integra suporte de compilador e de tempo de execução para habilitar computação aproximada em aplicações de \gls{hpc} utilizando OpenMP. Ele permite que os desenvolvedores anotem regiões de código com diretivas de aproximação e avaliem o equilibrío entre precisão e desempenho. O \texttt{HPAC} oferece suporte a técnicas como perforação de laço, memoização de entrada e saída, além de fornecer ferramentas para avaliar o impacto dessas técnicas na execução paralela.